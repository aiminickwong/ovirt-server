#!/bin/bash

OVIRT_DIR=/usr/share/ovirt-server
OVIRT_CFG=/etc/ovirt-server

DATABASE=ovirt
USERNAME=ovirt

EXISTS_FILE=${OVIRT_CFG}/db/exists
PW_FILE=${OVIRT_CFG}/db/dbaccess
STEP_TICKER=0.fedora.pool.ntp.org
STEP_FILE=/etc/ntp/step-tickers
SASL_FILE=/etc/sasl2/libvirt.conf
LDAP_CFG=${OVIRT_DIR}/config/ldap.yml

OVIRT_SVCS="ovirt-host-browser ovirt-host-keyadd ovirt-host-status \
            ovirt-host-collect ovirt-mongrel-rails ovirt-taskomatic"
ENABLE_SVCS="ntpdate ntpd httpd postgresql libvirtd collectd"

# This checks to see if we're running on a bundled/developer install.
# If we are, set PROD_INST to false
PROD_INST=true
if [ "$(hostname)" == "management.priv.ovirt.org" ]; then
    PROD_INST=false
fi

usage() {
    echo "usage: $0 [-p password]"
    echo "  -p : password to use for database connections, if omitted"
    echo "       a random password will be generated"
    exit 1
} >&2

find_srv() {
    local dnsreply
    
    dnsreply=$(dig +short -t srv _$1._$2.$(dnsdomainname))
    if [ $? -eq 0 ]; then
        set _ $dnsreply; shift
        SRV_HOST=$4; SRV_PORT=$3
    else
        SRV_HOST=; SRV_PORT=
    fi
}

find_ldap_base() {
    local found=0
    
    domain=$(echo $SRV_HOST | cut -d. -f 2-)
    while [ -n "$domain" ]; do
        base=$(echo $domain | awk -F. '{ for(i=1; i <= NF; i++) { printf("dc=%s", $(i)); if(i<NF) printf(","); } }')
        ldapsearch -h $SRV_HOST -p $SRV_PORT -x \
            -b "cn=users,cn=accounts,$base" -LLL uid > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            found=1
            break
        fi
        
        if ! echo $domain | grep "\." > /dev/null 2>&1 ; then
            domain=""
        else
            domain=$(echo $domain | cut -d. -f 2-)
        fi
    done
    
    if [ $found -eq 1 ]; then
        echo $base
        return 0
    else
        return 1
    fi   
}

# wait_for_service 'test command' max_retries seconds_to_sleep_between_retries
wait_for_service() {
  local testcmd=$1; shift
  local n_retries=$1; shift
  local sleep_seconds=$1; shift
  local total=$((n_retries*sleep_seconds))

  while [ $n_retries -gt 0 ]
  do
    eval "$testcmd" > /dev/null 2>&1 && return 0
    echo service not ready yet, retrying...
    n_retries=$((n_retries-1))
    sleep $sleep_seconds
  done
  printf 'service not ready after %d seconds, giving up\n' $total 1>&2
  return 1
}

PASSWD=
for i ; do
    case $1 in
        -p)
            [ $# -lt 2 ] && usage
            PASSWD="$2"
            shift; shift;;
        -?|-*)
            usage;;
    esac
done

{
for svc in $ENABLE_SVCS $OVIRT_SVCS; do
    chkconfig $svc on
done
} > /dev/null 2>&1

# grab ldap server from DNS
find_srv ldap tcp
if [ -n "$SRV_HOST" -a -n "$SRV_PORT" ]; then
    SRV_HOST=${SRV_HOST%.}
    srv_base=$(find_ldap_base)
    [ $? != 0 ] && echo "Failed to determine base for ldap" && exit 1
    
    sed -i -e "s/host: .*/host: $SRV_HOST/g" \
        -e "s/port: .*/port: $SRV_PORT/g" \
        -e "s/base: .*/base: $srv_base/g" \
        $LDAP_CFG
else
    # FIXME: Eventually this script should prompt for things that can't
    # be found in DNS SRV records.
    echo "Failed to get ldap host/port" && exit 1
fi

# setup an NTP step-ticker
if [ -f $STEP_FILE ]; then
    if ! grep "^$${STEP_TICKER}$" $STEP_FILE > /dev/null 2>&1 ; then
        echo $STEP_TICKER >> $STEP_FILE
    fi
fi

# setup gssapi in the mech_list
if [ `egrep -c '^mech_list: gssapi' $SASL_FILE` -eq 0 ]; then
    sed -i -e 's/^\([[:space:]]*mech_list.*\)/#\1/' $SASL_FILE
    echo "mech_list: gssapi" >> $SASL_FILE
fi

# if we are developer/bundled install, remove default network
# so dnsmasq from libvirt doesn't interfere with the dev/bundled
# dnsmasq
if [[ "$PROD_INST" == "false" ]]; then
    service libvirtd status > /dev/null 2>&1 || service libvirtd start > /dev/null 2>&1
    wait_for_service 'virsh connect' 10 2 || exit 1
    virsh net-destroy default
    virsh net-undefine default
fi

service postgresql stop > /dev/null 2>&1
service postgresql initdb > /dev/null 2>&1
echo "local all all trust" > /var/lib/pgsql/data/pg_hba.conf 
echo "host all all 127.0.0.1 255.255.255.0 trust" >> /var/lib/pgsql/data/pg_hba.conf 
service postgresql stop > /dev/null 2>&1
service postgresql start
[ $? != 0 ] && echo "Failed to start database" && exit 1
wait_for_service 'psql -l -U postgres' 10 2 || exit 1

if [ -z $PASSWD ]; then
    # generate random pg user password
    PASSWD=$(/usr/bin/pwgen -1 -n 8 -s)
fi

echo -e "${PASSWD}\n" > $PW_FILE

# drop old db
su - postgres -c "/usr/bin/dropdb $DATABASE > /dev/null 2>&1"

# create new DB
su - postgres -c "/usr/bin/createdb $DATABASE"
[ $? != 0 ] && echo "Failed to create database $DATABASE" && exit 1

su - postgres -c "psql --dbname $DATABASE <<EOF
    DROP ROLE $USERNAME;
EOF" > /dev/null 2>&1

su - postgres -c "psql --dbname $DATABASE <<EOF
    CREATE ROLE $USERNAME LOGIN PASSWORD '$PASSWD'
    NOINHERIT
    VALID UNTIL 'infinity';
    GRANT ALL ON DATABASE $DATABASE TO $USERNAME;
EOF"
[ $? != 0 ] && echo "Failed to run database setup" && exit 1

touch $EXISTS_FILE

cd ${OVIRT_DIR}
mkdir -p log
export RAILS_ENV="production" && rake db:migrate
cd -

${OVIRT_DIR}/script/grant_admin_privileges ovirtadmin
[ $? != 0 ] && echo "Failed to grant ovirtadmin privileges" && exit 1

ovirt-add-host $(hostname) ${OVIRT_DIR}/ovirt.keytab

for svc in $ENABLE_SVCS; do
    service $svc start
done

exit 0
